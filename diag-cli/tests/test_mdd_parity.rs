//! MDD parity tests: verify that all three pipelines produce equivalent MDD.
//!
//! The "golden triangle" - three independent sources must agree:
//! 1. **Reference MDD** - produced by CDA from ODX (testcontainer/odx/)
//! 2. **YAML -> MDD** - our Rust pipeline from YAML fixtures
//! 3. **ODX -> MDD** - our Rust pipeline from PDX fixtures (generated by odxtools)
//!
//! ## What is compared
//!
//! All checks are **hard assertions** (test fails if violated):
//! - ECU name
//! - Variant count and names
//! - Base variant: service count, DTC count, state chart count
//! - Byte size within +-5% of reference
//! - Per-service param counts (request and positive response)
//! - Service name sets must match (no extra or missing services)
//! - Structural counts (com_param_refs, funct_classes)

use diag_ir::*;
use diag_odx::pdx_reader::read_pdx_from_reader;
use diag_yaml::parse_yaml;
use mdd_format::reader::read_mdd_bytes;
use mdd_format::writer::{WriteOptions, write_mdd_bytes};
use std::collections::BTreeSet;
use std::fmt::Write;
use std::io::Cursor;

// ── Fixtures ──────────────────────────────────────────────────────────

fn flxc1000_yaml() -> &'static str {
    include_str!("../../test-fixtures/yaml/FLXC1000.yml")
}
fn flxcng1000_yaml() -> &'static str {
    include_str!("../../test-fixtures/yaml/FLXCNG1000.yml")
}
fn flxc1000_ref_mdd() -> &'static [u8] {
    include_bytes!("../../test-fixtures/mdd/FLXC1000.mdd")
}
fn flxcng1000_ref_mdd() -> &'static [u8] {
    include_bytes!("../../test-fixtures/mdd/FLXCNG1000.mdd")
}
fn flxc1000_pdx() -> &'static [u8] {
    include_bytes!("../../test-fixtures/odx/FLXC1000.pdx")
}
fn flxcng1000_pdx() -> &'static [u8] {
    include_bytes!("../../test-fixtures/odx/FLXCNG1000.pdx")
}

// ── Helpers ───────────────────────────────────────────────────────────

const SIZE_TOLERANCE_PERCENT: f64 = 5.0;

/// Build MDD bytes from YAML source.
fn yaml_to_mdd(yaml: &str) -> Vec<u8> {
    let db = parse_yaml(yaml).unwrap();
    let fbs = ir_to_flatbuffers(&db);
    write_mdd_bytes(&fbs, &WriteOptions::default()).unwrap()
}

/// Build MDD bytes from PDX (ODX archive).
fn odx_to_mdd(pdx: &[u8]) -> Vec<u8> {
    let db = read_pdx_from_reader(Cursor::new(pdx)).unwrap();
    let fbs = ir_to_flatbuffers(&db);
    write_mdd_bytes(&fbs, &WriteOptions::default()).unwrap()
}

/// Deserialize MDD bytes to IR.
fn mdd_to_ir(mdd: &[u8]) -> DiagDatabase {
    let (_meta, fbs) = read_mdd_bytes(mdd).unwrap();
    flatbuffers_to_ir(&fbs).unwrap()
}

/// Normalize variant short_name by stripping ECU name prefix.
fn normalize_name<'a>(name: &'a str, ecu_prefix: &str) -> &'a str {
    name.strip_prefix(ecu_prefix).unwrap_or(name)
}

/// Collect content differences between two DiagDatabases.
fn collect_diffs(a: &DiagDatabase, b: &DiagDatabase, label: &str) -> Vec<String> {
    let mut diffs = Vec::new();
    let ecu_prefix = format!("{}_", a.ecu_name);

    // For ODX-sourced IR: non-base variants have inherited (flattened) services.
    // Collect base variant service names to filter them out when comparing non-base.
    let a_base_svc: BTreeSet<&str> = a
        .variants
        .iter()
        .find(|v| v.is_base_variant)
        .map(|v| {
            v.diag_layer
                .diag_services
                .iter()
                .map(|s| s.diag_comm.short_name.as_str())
                .collect()
        })
        .unwrap_or_default();
    let b_base_svc: BTreeSet<&str> = b
        .variants
        .iter()
        .find(|v| v.is_base_variant)
        .map(|v| {
            v.diag_layer
                .diag_services
                .iter()
                .map(|s| s.diag_comm.short_name.as_str())
                .collect()
        })
        .unwrap_or_default();

    for a_v in &a.variants {
        let vname = normalize_name(&a_v.diag_layer.short_name, &ecu_prefix);
        let b_v = b
            .variants
            .iter()
            .find(|bv| normalize_name(&bv.diag_layer.short_name, &ecu_prefix) == vname);
        let Some(b_v) = b_v else { continue };

        let prefix = format!("{label}/{vname}");
        let a_layer = &a_v.diag_layer;
        let b_layer = &b_v.diag_layer;

        // For non-base variants, filter out inherited services before comparison.
        let a_svc_names: BTreeSet<&str> = a_layer
            .diag_services
            .iter()
            .map(|s| s.diag_comm.short_name.as_str())
            .filter(|n| a_v.is_base_variant || !a_base_svc.contains(n))
            .collect();
        let b_svc_names: BTreeSet<&str> = b_layer
            .diag_services
            .iter()
            .map(|s| s.diag_comm.short_name.as_str())
            .filter(|n| b_v.is_base_variant || !b_base_svc.contains(n))
            .collect();

        for s in a_svc_names.difference(&b_svc_names) {
            diffs.push(format!("{prefix}: service {s:?} only in A"));
        }
        for s in b_svc_names.difference(&a_svc_names) {
            diffs.push(format!("{prefix}: service {s:?} only in B"));
        }

        // Per-service param count diffs (for common services on base variant)
        if a_v.is_base_variant {
            for a_svc in &a_layer.diag_services {
                let svc_name = &a_svc.diag_comm.short_name;
                let b_svc = b_layer
                    .diag_services
                    .iter()
                    .find(|s| s.diag_comm.short_name == *svc_name);
                let Some(b_svc) = b_svc else { continue };

                if let (Some(ar), Some(br)) = (&a_svc.request, &b_svc.request) {
                    if ar.params.len() != br.params.len() {
                        diffs.push(format!(
                            "{prefix}/{svc_name}: request param count {} vs {}",
                            ar.params.len(),
                            br.params.len()
                        ));
                    }
                }
                for (i, (ar, br)) in a_svc
                    .pos_responses
                    .iter()
                    .zip(b_svc.pos_responses.iter())
                    .enumerate()
                {
                    if ar.params.len() != br.params.len() {
                        diffs.push(format!(
                            "{prefix}/{svc_name}: pos_resp[{i}] param count {} vs {}",
                            ar.params.len(),
                            br.params.len()
                        ));
                    }
                }
            }
        }

        // Structural counts
        if a_layer.com_param_refs.len() != b_layer.com_param_refs.len() {
            diffs.push(format!(
                "{prefix}: com_param_refs {} vs {}",
                a_layer.com_param_refs.len(),
                b_layer.com_param_refs.len()
            ));
        }
        if a_layer.funct_classes.len() != b_layer.funct_classes.len() {
            diffs.push(format!(
                "{prefix}: funct_classes {} vs {}",
                a_layer.funct_classes.len(),
                b_layer.funct_classes.len()
            ));
        }
    }

    diffs
}

/// Assert two DiagDatabases have identical content.
fn assert_content_parity(a: &DiagDatabase, b: &DiagDatabase, label: &str) {
    let ecu_prefix = format!("{}_", a.ecu_name);

    // ECU name
    assert_eq!(a.ecu_name, b.ecu_name, "{label}: ECU name mismatch");

    // Variant count
    assert_eq!(
        a.variants.len(),
        b.variants.len(),
        "{label}: variant count mismatch ({} vs {})",
        a.variants.len(),
        b.variants.len()
    );

    // Variant names (normalized, sorted)
    let mut a_names: Vec<_> = a
        .variants
        .iter()
        .map(|v| normalize_name(&v.diag_layer.short_name, &ecu_prefix).to_string())
        .collect();
    let mut b_names: Vec<_> = b
        .variants
        .iter()
        .map(|v| normalize_name(&v.diag_layer.short_name, &ecu_prefix).to_string())
        .collect();
    a_names.sort();
    b_names.sort();
    assert_eq!(a_names, b_names, "{label}: variant names differ");

    // DTC count
    assert_eq!(
        a.dtcs.len(),
        b.dtcs.len(),
        "{label}: DTC count mismatch ({} vs {})",
        a.dtcs.len(),
        b.dtcs.len()
    );

    // State charts
    for a_v in &a.variants {
        let vname = normalize_name(&a_v.diag_layer.short_name, &ecu_prefix);
        let b_v = b
            .variants
            .iter()
            .find(|bv| normalize_name(&bv.diag_layer.short_name, &ecu_prefix) == vname)
            .unwrap();
        assert_eq!(
            a_v.diag_layer.state_charts.len(),
            b_v.diag_layer.state_charts.len(),
            "{label}/{vname}: state chart count mismatch"
        );
    }

    // Content diffs (services, params, structural counts)
    let diffs = collect_diffs(a, b, label);
    if !diffs.is_empty() {
        let mut msg = format!("{label}: {} content difference(s)\n", diffs.len());
        for d in &diffs {
            let _ = writeln!(msg, "  {d}");
        }
        panic!("{msg}");
    }
}

/// Assert byte size is within tolerance.
fn assert_size_parity(a_mdd: &[u8], b_mdd: &[u8], label: &str) -> f64 {
    let ratio = a_mdd.len() as f64 / b_mdd.len() as f64;
    let deviation_pct = (ratio - 1.0).abs() * 100.0;
    assert!(
        deviation_pct <= SIZE_TOLERANCE_PERCENT,
        "{label}: MDD byte size deviation {deviation_pct:.1}% exceeds +-{SIZE_TOLERANCE_PERCENT}% \
         ({} bytes vs {} bytes)",
        a_mdd.len(),
        b_mdd.len()
    );
    deviation_pct
}

/// The golden triangle: three independent pipelines must produce the same
/// diagnostic content (services, params, variants, state charts).
///
/// ```text
///        Reference MDD
///       (CDA from ODX)
///        /           \
///  content=     content=
///       /             \
///  YAML -> MDD  ==  ODX -> MDD
/// ```
///
/// Byte size parity (+-5%) is checked for YAML vs reference. ODX -> MDD is
/// expected to be larger because the ODX parser resolves PARENT-REF inheritance,
/// producing flattened services on each ECU variant. The reference MDD stores
/// services only on the base variant (non-base variants inherit at runtime).
fn assert_golden_triangle(yaml: &str, ref_mdd: &[u8], pdx: &[u8], name: &str) {
    let yaml_mdd = yaml_to_mdd(yaml);
    let odx_mdd = odx_to_mdd(pdx);

    let ref_ir = mdd_to_ir(ref_mdd);
    let yaml_ir = mdd_to_ir(&yaml_mdd);
    let odx_ir = mdd_to_ir(&odx_mdd);

    // ── 1. YAML vs Reference MDD (content) ──────────────────────────

    assert_content_parity(&yaml_ir, &ref_ir, &format!("{name} [YAML vs REF]"));

    // ── 2. ODX vs Reference MDD (content) ───────────────────────────

    assert_content_parity(&odx_ir, &ref_ir, &format!("{name} [ODX vs REF]"));

    // ── 3. ODX vs YAML (content) ────────────────────────────────────

    assert_content_parity(&odx_ir, &yaml_ir, &format!("{name} [ODX vs YAML]"));

    // ── 4. Byte size parity ─────────────────────────────────────────
    //
    // YAML -> MDD must be within +-5% of reference (same storage model).
    // ODX -> MDD is larger due to flattened inheritance - log but don't fail.

    let yaml_dev = assert_size_parity(&yaml_mdd, ref_mdd, &format!("{name} [YAML vs REF size]"));

    let odx_ratio = odx_mdd.len() as f64 / ref_mdd.len() as f64;
    let odx_dev = (odx_ratio - 1.0).abs() * 100.0;

    eprintln!("{name}: GOLDEN TRIANGLE - all three pipelines agree on content");
    eprintln!("  Reference MDD: {} bytes", ref_mdd.len());
    eprintln!(
        "  YAML -> MDD:   {} bytes ({yaml_dev:+.1}%)",
        yaml_mdd.len()
    );
    eprintln!(
        "  ODX  -> MDD:   {} bytes ({odx_dev:+.1}%, larger due to flattened inheritance)",
        odx_mdd.len()
    );
}

// ── Tests ─────────────────────────────────────────────────────────────

#[test]
fn golden_triangle_flxc1000() {
    assert_golden_triangle(
        flxc1000_yaml(),
        flxc1000_ref_mdd(),
        flxc1000_pdx(),
        "FLXC1000",
    );
}

#[test]
fn golden_triangle_flxcng1000() {
    assert_golden_triangle(
        flxcng1000_yaml(),
        flxcng1000_ref_mdd(),
        flxcng1000_pdx(),
        "FLXCNG1000",
    );
}
